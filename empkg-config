#!/usr/bin/env python2

import argparse
import os
import subprocess
import sys
from tools import pkg as pkg_module

class Arguments:
	def __init__(self):
		self.parser = argparse.ArgumentParser()

		self.parser.add_argument( 'package_names', metavar='LIBRARY', type=str, nargs='*',
		                          help='packages to get configuration for' )

		self.parser.add_argument( '--libs', action='store_true',
		                          help='sum the integers (default: find the max)' )

		self.parser.add_argument( '--cflags', action='store_true',
		                          help='sum the integers (default: find the max)' )

		self.parser.add_argument( '--exists', action='store_true',
		                          help='sum the integers (default: find the max)' )

		self.parser.add_argument( '--modversion', action='store_true',
		                          help='sum the integers (default: find the max)' )

		self.parser.add_argument( '--print-errors', action='store_true',
		                          help='sum the integers (default: find the max)' )

		self.parser.add_argument( '--silence-errors', action='store_true',
		                          help='sum the integers (default: find the max)' )
		
		self.parser.add_argument( '--ensure', action='store_true',
		                          help='Ensures that packages get downloaded and built before accessing' )
		
		self.args = self.parser.parse_args()

	def delegate( self, name ):
		if getattr( self.args, name, False ):
			return '--' + name
		else:
			return ''
	
def failOnNonDir( package ):
	packagePath = package.path()
	if os.path.isdir( packagePath ):
		return packagePath
	else:
		name = self.name
		print >> sys.stderr, "Package" + name + " was not found in the empkg-config search path."
		print >> sys.stderr, "No package '" + name + "' found"
		sys.exit( -1 )

def failOnNonBuilt( version ):
	if not version.is_built():
		""" We mimic pkg-config behavior and they are not reporting
		   which I find utterly stupid """
		sys.exit( -1 )

args = Arguments()

versions = []

for package_name in args.args.package_names:
	versions.append( pkg_module.Package(package_name).highest_version() )

if args.args.ensure:
	# Make sure we have all packages valid and built
	for version in versions:
		if not version.is_downloaded():
			version.download()
		
		if not version.is_built():
			version.built()

cflags = args.delegate( "cflags" )
libs   = args.delegate( "libs"   )
exists = args.delegate( "exists" )

# Use configs directly so we do not collide with anything system specified
pc_configs = []

result = []

for version in versions:
	failOnNonDir  ( version.package )
	failOnNonBuilt( version )
	assert version.has_pc_file()
	
	system_path = version.system_path()
	search_paths = [ os.path.join(system_path, 'lib'  , 'pkgconfig'),
	                 os.path.join(system_path, 'share', 'pkgconfig')  ]
	if hasattr( env, 'PKG_CONFIG_PATH' ):
		search_paths.append( env['PKG_CONFIG_PATH'] )

	env = os.environ.copy()
	env['PKG_CONFIG_PATH'] = os.pathsep.join( search_paths )
	
	# To ease use with Emscripten we define emscripten_prefix for the users
	defines = '--define-variable=prefix=' + system_path

	command = ['pkg-config', defines, cflags, libs, exists, ]
	
	try:
		result.append( subprocess.check_output(command, env=env) )
	except CalledProcessError, e:
		sys.exit( e.returncode )

# We collected all output of pkg-config
print ' '.join( result )

