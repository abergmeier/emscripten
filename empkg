#!/usr/bin/env python2

import argparse
from tools import pkg as pkg_module

class Arguments:
	def __init__( self ):
		self.parser = argparse.ArgumentParser()
		
		packages_dict = dict( metavar='PACKAGE', type=str, nargs='*' )
		subparsers = self.parser.add_subparsers()
		def add_build_parser( name ):
			buildParser = subparsers.add_parser( name )
			buildParser.add_argument( 'build_package_names',
			                          help='packages to build',
			                          **packages_dict )
		
			buildParser.add_argument( '--download', action='store_true',
			                          help='ensures that packages get downloaded before building' )
		def add_get_parser( name ):
			getParser = subparsers.add_parser( name )
			getParser.add_argument( 'get_package_names',
			                        help='package sources to download',
			                        **packages_dict )
		def add_purge_parser( name ):
			purgeParser = subparsers.add_parser( name )
			purgeParser = purgeParser.add_argument( 'purge_package_names',
			                                        help='package sources to remove',
			                                        **packages_dict )
		
		def add_remove_parser( name ):
			removeParser = subparsers.add_parser( name )
			removeParser.add_argument( 'remove_package_names',
			                           help='packages to remove',
			                           **packages_dict )
		
		add_get_parser   ( 'get'    )
		add_build_parser ( 'build'  )
		add_remove_parser( 'remove' )
		add_purge_parser ( 'purge'  )
		
		self.args = self.parser.parse_args()
	
	def handle_build( self, package_versions ):
		versions = []
		
		for package_version in package_versions:
			versions.append(package_version)
		
		if( self.args.download ):
			for version in versions:
				version.download()
		
		for version in versions:
			version.build()
	
	def handle_get( self, package_versions ):
		to_download = []
		
		for package_version in package_versions:
			to_download.append(package_version)
		
		# Build dependency list
		rootNode = PkgNode()
		for version in to_download:
			rootNode.addEdge(version)
		
		to_download = rootNode.resolve()
		
		print 'The following package sources will be installed:'
		for version in to_download:
			print version.package.name + ' - ' + version.string

		for version in to_download:
			version.fetch()
	
	def handle_purge( self, package_versions ):
		to_purge = []
		for package_version in package_versions:
			to_purge.append(package_version)
		
		print 'The following packages and sources will be removed:'
		for version in to_purge:
			print version.package.name + ' - ' + version.string
		
		for version in to_purge:
			if os.path.isdir( version.system_path() ):
				shutil.rmtree( version.system_path() )
			
			if os.path.isdir( version.path() ):
				shutil.rmtree( version.path() )
	
	def handle_remove( self, package_versions ):
		to_remove = []
		for package_version in package_versions:
			to_remove.append(package_version)
		
		print 'The following packages will be removed:'
		for version in to_remove:
			print version.package.name + ' - ' + version.string
		
		for version in to_remove:
			if os.path.isdir( version.system_path() ):
				shutil.rmtree( version.system_path() )
		
	def handle( self ):
		config = dict( get_package_names    = self.handle_get,
		               build_package_names  = self.handle_build,
		               remove_package_names = self.handle_remove,
		               purge_package_names  = self.handle_purge )
		for name, handler in config.iteritems():
			package_names = getattr( self.args, name, [] )
			
			if len( package_names ) is 0:
				continue
			
			package_versions = []
			
			# Extract version information
			for i in range(len(package_names)):
				version_tuple = package_names[i].split('=')
				
				package_name = version_tuple[0]
				if len(version_tuple) is 1:
					package_version = pkg_module.Package(package_name).highest_version()
				else:
					package_version = pkg_module.Package(package_name).version(version_tuple[1])
				package_versions.append(package_version)
			
			handler( package_versions )

args = Arguments()
args.handle()

class PkgNode(pkg_module.Node):
  def __init__(self):
    pkg_module.Node.__init__()
  
  def resolve(self):
    return _resolve(self)

  def _resolve(node, nodes, resolved, unresolved_parents):
    if len(node.edges) is 0:
      # Try to load edges
      for package_name, package_version in edge.version.config.dependencies.iteritems():
        version = pkg_module.Package(package_name).version(package_version)
        node = pkg_module.Node(version)
        self.addEdge(node)
    
    for edge in node.edges:
      if edge in resolved:
        continue
      
      if edge in unresolved_parents:
        raise Exception('Smells like circular dependency between %s and %s' % (edge.version.name, node.version.name) )
      _resolve(edge, nodes, resolved, unresolved_parents)
    resolved.append(node)
    unresolved_parents.remove(node)




